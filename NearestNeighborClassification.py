##################
#ES2 Project 2
#Steps 2&3
#NAME: Kevin Zhang
#HOURS NEEDED: 4
#I worked alone on this part.
#################

import numpy as np
import matplotlib.pyplot as plt
import random as r
import math 
import scipy.stats


# FUNCTIONS
def normalizeData(glucose, hemoglobin, classification):
    #this function takes the glucose, hemoglobin and classification arrays as inputs
    #it normalizes glucose and hemoglobin on a 0-1 scale (using their respective min and max)
    #it returns these new glucose and hemoglobin arrays; classification is unchanged
    glucose_scaled = (glucose - 70) / 420
    hemoglobin_scaled = (hemoglobin - 3.1) / 14.7
    return(glucose_scaled, hemoglobin_scaled, classification)

def openckdfile():
    #this function extracts the original glucose, hemoglobin and classification arrays from the data file
    #after extraction, it calls normalizeData to normalize the glucose and hemoglobin arrays
    #it then returns the normalized glucose and hemoglobin arrays, and classification
    glucose, hemoglobin, classification = np.loadtxt('ckd.csv', delimiter=',', skiprows=1, unpack=True)
    return normalizeData(glucose, hemoglobin, classification)

def graphData(glucose, hemoglobin, classification):
    #this function takes the glucose, hemoglobin and classification arrays as inputs, and creates a scatterplot
    #it plots the points (hemoglobin, glucose) with a classification value of 1, and 0, respectively, 
    #separately on the same plot, using blue and yellow markers respectively
    plt.figure()
    plt.title('Glucose vs. Hemoglobin')
    plt.plot(hemoglobin[classification==1],glucose[classification==1], "b.", label = "CKD")
    plt.plot(hemoglobin[classification==0],glucose[classification==0], "y.", label = "No CKD")
    plt.xlabel("Hemoglobin")
    plt.ylabel("Glucose")
    plt.legend()
    plt.show()

def createTestCase():
    #this function takes no inputs, and returns a tuple of 2 floats corresponding to random glucose and hemoglobin levels
    #these values are generated by taking a random integer from 0-100 and dividing by 100 to get a value from 0-1
    newglucose = r.randint(0, 100) / 100
    newhemoglobin = r.randint(0, 100) / 100
    return (newglucose, newhemoglobin)

def calculateDistanceArray(newglucose, newhemoglobin, glucose, hemoglobin):
    #this function takes four inputs: the glucose and hemoglobin values of the test case, and the glucose and hemoglobin arrays
    #it uses the distance formula to calculate the distance from each point in the arrays to the test case
    #it appends each calculated distance to an array, and returns this array
    distancearray =[]
    for i in range(len(glucose)):
        distance = math.sqrt((glucose[i] - newglucose) ** 2 + (hemoglobin[i] - newhemoglobin) ** 2)
        distancearray.append (distance)
    return distancearray

def nearestNeighborClassifier (newglucose, newhemoglobin, glucose, hemoglobin, classification):
    #this function takes five inputs: the glucose and hemoglobin values of the test case, and the glucose, hemoglobin and classification arrays
    #it calls calculateDistanceArray to generate an array of distances to the test case
    #it then finds the index of the minimum value in this distance array
    #it finds the value at the given index in the classification array, and returns this
    distancearray = calculateDistanceArray(newglucose, newhemoglobin, glucose, hemoglobin)
    minindex = np.argmin(distancearray)
    minclass = classification[minindex]
    return minclass

def graphTestCase (newglucose, newhemoglobin, glucose, hemoglobin, classification):
    #this function takes five inputs: the glucose and hemoglobin values of the test case, and the glucose, hemoglobin and classification arrays
    #it functions identically to graphData (e.g. plotting the two separate classifications separately),
    #but additionally plots the test case with a large red marker
    plt.figure()
    plt.title('Glucose vs. Hemoglobin')
    plt.plot(hemoglobin[classification==1],glucose[classification==1], "b.", label = "CKD")
    plt.plot(hemoglobin[classification==0],glucose[classification==0], "y.", label = "No CKD")
    plt.plot(newhemoglobin, newglucose, 'r.', markersize = 20, label = 'Test Case')
    plt.xlabel("Hemoglobin")
    plt.ylabel("Glucose")
    plt.legend()
    plt.show()

def kNearestNeighborClassifier (k, newglucose, newhemoglobin, glucose, hemoglobin, classification):
    #this function takes 6 inputs: k, a test case, and the three initial arrays
    #it calls calculateDistanceArray to create an array of distances from each point to the test case
    #it then returns the indices of these distances, in order from least to greatest distance
    #it takes the first k values as a slice, k_indices, and makes an array of the values of classification at these indices
    #it then returns the mode of these classifications
    sorteddistances = np.argsort(calculateDistanceArray(newglucose, newhemoglobin, glucose, hemoglobin))
    k_indices = sorteddistances[:k]
    k_classifications = classification[k_indices]
    mode = scipy.stats.mode(k_classifications)
    return mode[0]


# MAIN SCRIPT
glucose, hemoglobin, classification = openckdfile()

graphData(glucose, hemoglobin, classification)

#creates 10 test cases, plots these test cases 
#prints the classifications found using nearestNeighborClassifier and kNearestNeighborClassifier
#1 represents CKD, 0 represents no CKD
for i in range(10):
    newglucose, newhemoglobin = createTestCase()
    graphTestCase (newglucose, newhemoglobin, glucose, hemoglobin, classification)
    print (nearestNeighborClassifier(newglucose, newhemoglobin, glucose, hemoglobin, classification))
    print (kNearestNeighborClassifier(5, newglucose, newhemoglobin, glucose, hemoglobin, classification))
